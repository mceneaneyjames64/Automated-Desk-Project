#!/home/jd/Dev/DeskControl/.venv/bin/python

import asyncio
import paho.mqtt.client as paho
from aiomqtt import Client, MqttError

################################################################################
#                           CONFIGURATION
################################################################################

# Command constants for the desk.
CMD_monitor_up = 0x1
CMD_monitor_down = 0x2
CMD_keyboard_up = 0x3
CMD_keyboard_down = 0x4
CMD_monitor_tilt_up = 0x4
CMD_monitor_tilt_down = 0x6
CMD_preset_one = 0x7
CMD_preset_two = 0x8
CMD_preset_three = 0x9
CMD_set_preset_one = 0x10
CMD_set_preset_two = 0x11
CMD_set_preset_three = 0x12
CMD_calibrate = 0x13
CMD_emergency_stop =0x14

################################################################################
#                           MOVEMENT FUNCTIONS
################################################################################

# One-shot (tap) functions.
async def monitor_up():
    print("One-shot: Monitor Up")

async def monitor_down():
    print("One-shot: Monitor Down")

async def keyboard_up():
    print("One-shot: Keyboard Up")

async def keyboard_down():
    print("One-shot: Keyboard Down")

async def monitor_tilt_up():
    print("One-shot: Monitor Tilt Up")

async def monitor_tilt_down():
    print("One-shot: Monitor Tilt Down")

async def preset_one():
    print("Preset One...")

async def preset_two():
    print("Preset Two...")

async def preset_three():
    print("Preset Three...")

async def set_preset_one():
    print("Set Preset One...")

async def set_preset_two():
    print("Set Preset Two...")

async def set_preset_three():
    print("Set Preset Three...")

async def calibrate():
    print("Calibrate...")

async def emergency_stop():
    print("Emergency Stop...")

#Run regular movement with delay for continuous command
async def continuous_command(command_key: int):
        #up/down button on remote function
        try:
            while True:
                await asyncio.sleep(0.1)
        except asyncio.CancelledError:
            print(f"Continuous command {command_key} cancelled.")
            # Clean exit on cancellation.

################################################################################
#                   MQTT INTEGRATION & CONTINUOUS TASKS
################################################################################

# MQTT broker settings.
MQTT_BROKER = "192.168.1.138" # Broker IP
MQTT_PORT = 1883
MQTT_TOPIC = "home/desk/command"
MQTT_USERNAME = "mqtttest" #Broker username
MQTT_PASSWORD = "VMIececapstone" #Broker password

# One-shot command mapping.
ONE_SHOT_COMMANDS = {
    "monitor_up": monitor_up,
    "monitor_down": monitor_down,
    "keyboard_up": keyboard_up,
    "keyboard_down": keyboard_down,
    "monitor_tilt_up": monitor_tilt_up,
    "monitor_tilt_down": monitor_tilt_down,
    "preset_one": preset_one,
    "preset_two": preset_two,
    "preset_three": preset_three,
    "set_preset_one": set_preset_one,
    "set_preset_two": set_preset_two,
    "set_preset_three": set_preset_three,
    "calibrate": calibrate,
    "emergency_stop": emergency_stop,
}

# Mapping for continuous (hold) commands.
CONTINUOUS_COMMANDS = {
    "monitor_up": CMD_monitor_up,
    "monitor_down": CMD_monitor_down,
    "keyboard_up": CMD_keyboard_up,
    "keyboard_down": CMD_keyboard_down,
    "monitor_tilt_up": CMD_monitor_tilt_up,
    "monitor_tilt_down": CMD_monitor_tilt_down,
}

# Dictionary to track active continuous tasks.
# For each command (e.g. "monitor_up"), we store a dict with keys: 'task' and 'last_update'
continuous_tasks = {}

# Timeout: if no repeated message arrives within this many seconds, cancel the continuous command.
CONTINUOUS_TIMEOUT = 0.3

async def mqtt_command_handler():
#Deal with MQTT messages to pass directly from home Assitnt to Raspberry Pi
    async with Client(MQTT_BROKER, port=MQTT_PORT, username=MQTT_USERNAME, password=MQTT_PASSWORD) as client:
        await client.subscribe(MQTT_TOPIC)
        print(f"Subscribed to MQTT topic: {MQTT_TOPIC}")
        async for message in client.messages:
            payload = message.payload.decode().strip()
            print(f"Received MQTT message: {payload}")

            if payload.startswith("start_"):
                cmd = payload[6:]  # e.g. "monitor_up"
                if cmd in CONTINUOUS_COMMANDS:
                    now = asyncio.get_event_loop().time()
                    if cmd in continuous_tasks:
                        # Update the last update time.
                        continuous_tasks[cmd]['last_update'] = now
                    else:
                        # Start a new continuous task.
                        task = asyncio.create_task(continuous_command(CONTINUOUS_COMMANDS[cmd]))
                        continuous_tasks[cmd] = {'task': task, 'last_update': now}
                        print(f"Started continuous command: {cmd}")
                else:
                    print(f"Unknown continuous command: {cmd}")

            #move once, not continuously
            elif payload in ONE_SHOT_COMMANDS:
                asyncio.create_task(ONE_SHOT_COMMANDS[payload]())
            else:
                print(f"Unknown command received: {payload}")

#code to cancel continuous command and for timeouts
async def continuous_task_monitor():
    while True:
        now = asyncio.get_event_loop().time()
        to_cancel = []
        for cmd, info in continuous_tasks.items():
            if now - info['last_update'] > CONTINUOUS_TIMEOUT:
                to_cancel.append(cmd)
        for cmd in to_cancel:
            task = continuous_tasks[cmd]['task']
            task.cancel()
            try:
                await task
            except asyncio.CancelledError:
                print(f"Stopped continuous command: {cmd}")
            continuous_tasks.pop(cmd, None)
        await asyncio.sleep(0.1)

################################################################################
#                           MAIN ENTRY POINT
################################################################################

async def main():
    mqtt_task = asyncio.create_task(mqtt_command_handler())
    continuous_monitor_task = asyncio.create_task(continuous_task_monitor())
    await asyncio.gather(mqtt_task, continuous_monitor_task)

if __name__ == "__main__":
    asyncio.run(main())
