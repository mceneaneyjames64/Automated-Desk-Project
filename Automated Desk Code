#This file is intended for the Python code

import asyncio
from bleak import BleakClient
from aiomqtt import Client, MqttError

#FIX ME: ADD BLUETOOTH ADDRESS AND FIX UUIDs FOR WRITING AND NITIFYING IF NEEDED
DESK_ADDRESS = "" 
WRITE_CHAR_UUID = "0000ffe9-0000-1000-8000-00805f9b34fb"
NOTIFY_CHAR_UUID = "0000ffe4-0000-1000-8000-00805f9b34fb"

# Command constants for the desk.
#protocol for talking to desk, when code received, desk knows to move
CMD_KEYBOARD_UP = 0x10 #code to move keyboard holder part of desk up
CMD_KEYBOARD_DOWN = 0x20 # code to move keyboard holder down

CMD_ROTATE_MONITOR_UP = 0x1 #code to rotate/tilt the monitor upwards
CMD_ROTATE_MONITOR_DOWN = 0x2 #code to rotate/tilt the monitor downwards

CMD_RAISE_MONITOR = 0x4 #code to raise the monitor up
CMD_LOWER_MONITOR = 0x8 #code to lower the monitor down

#####################################################################################
#                         BLUETOOTH UTILITY FUNCTIONS
#####################################################################################

def calc_checksum(packet: bytearray) -> int:
    total = sum(packet[:-1])
    return (~total) & 0xFF

def build_desk_command(key: int) -> bytes:
    pkt = bytearray(8)
    pkt[0] = 0xE5
    pkt[1] = 0xFE
    pkt[2] = 0x16
    pkt[3] = (key >> 0) & 0xFF
    pkt[4] = (key >> 8) & 0xFF
    pkt[5] = (key >> 16) & 0xFF
    pkt[6] = (key >> 24) & 0xFF
    pkt[7] = calc_checksum(pkt)
    return bytes(pkt)

######################################################################################
#                              DESK CONTROLLER CLASS
######################################################################################

class DeskController:
    #addresses
    def __init__(self, address: str, write_char_uuid: str):
        self.address = address
        self.write_char_uuid = write_char_uuid
        self.client = BleakClient(address)
        self.lock = asyncio.Lock()

    async def connect(self):
        #connect to bluetooth with address supplied
        if not self.client.is_connected:
            try:
                await self.client.connect()
                print("BLE connected")
            except Exception as e:
                print("BLE connection error:", e)

    async def ensure_connected(self):
        #ensure that the bluetooth is running
        #returns conenction or runs through again depending on outcome
        if not self.client.is_connected:
            print("BLE not connected, attempting reconnect...")
            await self.connect()
        return self.client.is_connected

    async def write_command(self, command_key: int):
        #writes to bed, publishes messages on error
        if await self.ensure_connected():
            cmd = build_desk_command(command_key) #see line 31 for function
            async with self.lock:
                try:
                    await self.client.write_gatt_char(self.write_char_uuid, cmd)
                except Exception as e:
                    print("Error writing command:", e)
                    await self.client.disconnect()
                    await self.connect()
        else:
            print("Could not connect to BLE device.")

    async def one_off_command(self, command_key: int):
        #equivalent to a preset command
        await self.write_command(command_key)

    async def continuous_command(self, command_key: int):
        #up/down button on remote function
        try:
            while True:
                await self.write_command(command_key)
                await asyncio.sleep(0.1)
        except asyncio.CancelledError:
            print(f"Continuous command {command_key} cancelled.")
            # Clean exit on cancellation.

# Global controller instance.
desk_controller = DeskController(DESK_ADDRESS, WRITE_CHAR_UUID)

####################################################################################
#                          MOVEMENT FUNCTIONS
####################################################################################

# One-shot (tap) functions.
async def keyboard_up():
    print("One-shot: Keyboard Up")
    await bed_controller.one_off_command(CMD_KEYBOARD_UP)

async def keyboard_down():
    print("One-shot: Keyboard Down")
    await bed_controller.one_off_command(CMD_KEYBOARD_DOWN)

async def monitor_tilt_up():
    print("One-shot: Monitor Tilt Up")
    await bed_controller.one_off_command(CMD_ROTATE_MONITOR_UP)

async def monitor_tilt_down():
    print("One-shot: Monitor Tilt Down")
    await bed_controller.one_off_command(CMD_ROTATE_MONITOR_DOWN)

async def raise_monitor_up():
    print("One-shot: Raise Monitor Up")
    await bed_controller.one_off_command(CMD_RAISE_MONITOR)

async def lower_monitor_down():
    print("One-shot: Lower Monitor Down")
    await bed_controller.one_off_command(CMD_LOWER_MONITOR)

################################################################################
#                   MQTT INTEGRATION & CONTINUOUS TASKS
################################################################################

# MQTT broker settings.
MQTT_BROKER = "" # FIXME: ADD Broker IP
MQTT_PORT = 1883 #FIXME: CHANGE MQTT PORT
MQTT_TOPIC = "home/desk/command"
MQTT_USERNAME = "" #Broker username
MQTT_PASSWORD = "" #Broker password

# One-shot command mapping.
ONE_SHOT_COMMANDS = {
    "keyboard_up": keyboard_up,
    "keyboard_down": keyboard_down,
    "monitor_tilt_up": monitor_tilt_up,
    "monitor_tilt_down": monitor_tilt_down,
    "raise_monitor_up": raise_monitor_up,
    "lower_monitor_down": lower_monitor_down,
}

# Mapping for continuous (hold) commands.
CONTINUOUS_COMMANDS = {
    "keyboard_up": CMD_KEYBOARD_UP,
    "keyboard_down": CMD_KEYBOARD_DOWN,
    "monitor_tilt_up": CMD_ROTATE_MONITOR_UP,
    "monitor_tilt_down": CMD_ROTATE_MONITOR_DOWN,
    "raise_monitor_up": CMD_RAISE_MONITOR,
    "lower_monitor_down": CMD_LOWER_MONITOR,
}

# Dictionary to track active continuous tasks.
# For each command (e.g. "keyboard_up"), we store a dict with keys: 'task' and 'last_update'
continuous_tasks = {}

# Timeout: if no repeated message arrives within this many seconds, cancel the continuous command.
CONTINUOUS_TIMEOUT = 0.3

#Handle continuous commands and one-shot commands
async def mqtt_command_handler():
    async with Client(MQTT_BROKER, port=MQTT_PORT, username=MQTT_USERNAME, password=MQTT_PASSWORD) as client:
        await client.subscribe(MQTT_TOPIC)
        print(f"Subscribed to MQTT topic: {MQTT_TOPIC}")
        async for message in client.messages:
            payload = message.payload.decode().strip()
            print(f"Received MQTT message: {payload}")

            if payload.startswith("start_"):
                cmd = payload[6:]  # e.g. "keyboard_up"
                if cmd in CONTINUOUS_COMMANDS:
                    now = asyncio.get_event_loop().time()
                    if cmd in continuous_tasks:
                        # Update the last update time.
                        continuous_tasks[cmd]['last_update'] = now
                    else:
                        # Start a new continuous task.
                        task = asyncio.create_task(desk_controller.continuous_command(CONTINUOUS_COMMANDS[cmd]))
                        continuous_tasks[cmd] = {'task': task, 'last_update': now}
                        print(f"Started continuous command: {cmd}")
                else:
                    print(f"Unknown continuous command: {cmd}")

            elif payload in ONE_SHOT_COMMANDS:
                asyncio.create_task(ONE_SHOT_COMMANDS[payload]())
            else:
                print(f"Unknown command received: {payload}")

#monitor continuous commands and tell them when to stop
async def continuous_task_monitor():
    while True:
        now = asyncio.get_event_loop().time()
        to_cancel = []
        for cmd, info in continuous_tasks.items():
            if now - info['last_update'] > CONTINUOUS_TIMEOUT:
                to_cancel.append(cmd)
        for cmd in to_cancel:
            task = continuous_tasks[cmd]['task']
            task.cancel()
            try:
                await task
            except asyncio.CancelledError:
                print(f"Stopped continuous command: {cmd}")
            continuous_tasks.pop(cmd, None)
        await asyncio.sleep(0.1)

#monitor bluetooth connection to make sure everythign works
async def ble_connection_monitor():
    while True:
        if not desk_controller.client.is_connected:
            print("BLE disconnected, attempting reconnect...")
            await desk_controller.connect()
        await asyncio.sleep(5)

################################################################################
#                           MAIN ENTRY POINT
################################################################################

async def main():
    await desk_controller.connect()
    mqtt_task = asyncio.create_task(mqtt_command_handler())
    monitor_task = asyncio.create_task(ble_connection_monitor())
    continuous_monitor_task = asyncio.create_task(continuous_task_monitor())
    await asyncio.gather(mqtt_task, monitor_task, continuous_monitor_task)

if __name__ == "__main__":
    asyncio.run(main())

